# stockScience
stockScience

## How to run
### stock_grain_ranking: python main.py -s 股票代码 -b 开始日期
例如：python main.py -s 600489 601088 -b 20240501

这是一个基于多因子模型的股票分析系统，结合技术指标和宏观经济数据进行量化交易决策。以下是核心模块解析：

### 一、系统架构
```
├── 数据获取模块 (fetch_stock_data)
├── 指标计算模块 (calculate_indicators)
├── 信号生成模块 (generate_signals)
├── 回测模块 (backtest_strategy)
├── 宏观评分模块 (get_macro_score)
└── 主程序 (数据缓存、多线程执行)
```

### 二、核心算法解析
1. **技术指标计算（calculate_indicators）**
| 指标 | 公式/参数 | 作用 |
|-------------|--------------------------------------------------------------------------|------------------|
| 移动平均线 | SMA(5) + SMA(20) | 判断短期趋势 |
| MACD | EMA(12) - EMA(26)，信号线=EMA(9) | 动量指标 |
| RSI | RSI = 100 - 100/(1 + RS)，周期14日，RS=平均涨幅/平均跌幅 | 超买超卖判断 |
| BOLL | 中轨=20日SMA，上下轨=中轨±2σ | 波动率通道 |
| 成交量指标 | volume_pct_change = (当日成交量 / 前3日均量) - 1 | 量能变化监测 |

2. **信号生成算法（generate_signals）**
    - **多维评分模型**：
总买入评分 = 0.3*MACD动量 + 0.2*BOLL评分 + 0.15*RSI背离 + 0.2*量能配合 + 0.15*宏观评分
总卖出压力 = 0.4*趋势衰减 + 0.3*超买系数 + 0.2*资金流出 + 0.1*黑天鹅指数
    - **动态阈值调整**：
```python
def dynamic_threshold(df):
    volatility = 标准差(收盘价日涨跌幅) * 100
    return 0.65 if volatility > 3% else 0.6
```
    - **信号生成条件**：
if 买入评分 ≥ 动态阈值 → 买入信号(1)
elif 卖出压力 ≥ 0.5 → 卖出信号(-1)
else → 无信号(0)

3. **宏观评分模型（get_macro_score）**
    - **指标构成与权重**：
总评分 = (0.3*CPI + 0.3*汇率 + 0.2*PMI + 0.2*GDP) * 0.15
    - **单项评分公式**：
| 指标 | 计算公式 |
|------|-------------------------------------------------------------------------|
| CPI | (CPI同比 - 2.5)/2，限制在0-1区间 |
| 汇率 | 1 - |USD/CNY - 6.8|/0.5，6.3-7.3为合理区间 |
| PMI | (制造业PMI - 45)/15，45-60为合理区间 |
| GDP | (GDP增速 - 4)/2，4%-6%为合理区间 |

### 三、系统工作流程
1. **数据准备阶段**
    - 缓存股票名称映射表
    - 预加载宏观数据（CPI、汇率、PMI、GDP）
    - 数据格式标准化处理
2. **个股分析阶段（多线程执行）**
获取历史数据 → 计算技术指标 → 生成交易信号 → 回测模拟 → 输出报告
3. **输出内容**
    - 最新宏观数据简报
    - 个股买卖建议
    - 多维评分详情
    - 累计收益率表现

### 四、创新设计
1. **动态阈值机制**：根据市场波动率自动调整买入阈值
2. **宏观因子融合**：将宏观经济数据量化为策略评分项
3. **异常处理机制**：
    - 数据获取失败时使用本地缓存
    - CPI数据异常时使用最近3个月数据
    - 默认值回退机制（如GDP数据缺失时返回0.1）

### 五、关键技术点
1. 使用pandas_ta实现高效指标计算
2. 多线程加速股票分析（ThreadPoolExecutor）
3. **时间序列处理**：
```python
# 季度日期解析
def parse_quarter(row):
    year = int(row['季度'].split('年')[0])
    q = int(row['季度'].split('第')[1][0])
    return pd.Timestamp(year=year, month=q*3-2, day=1)
```
该系统实现了技术面与基本面的量化融合，通过动态调整机制增强策略适应性，适合中短线交易决策。

### stock_pre_ranking 
1. cd stock_pre_ranking
2. pip install -r requirements.txt
3. python main.py